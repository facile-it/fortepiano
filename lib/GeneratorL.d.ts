import * as $generatorL from 'fp-ts/Alt';
import * as Alte from 'fp-ts/Alternative';
import * as Appli from 'fp-ts/Applicative';
import * as _Apply from 'fp-ts/Apply';
import * as Ch from 'fp-ts/Chain';
import * as Co from 'fp-ts/Compactable';
import * as Ei from 'fp-ts/Either';
import * as Eq from 'fp-ts/Eq';
import * as Ex from 'fp-ts/Extend';
import * as Fi from 'fp-ts/Filterable';
import * as FiWI from 'fp-ts/FilterableWithIndex';
import * as Fo from 'fp-ts/Foldable';
import * as FoWI from 'fp-ts/FoldableWithIndex';
import * as FIO from 'fp-ts/FromIO';
import { Lazy, Predicate, Refinement } from 'fp-ts/function';
import * as Fu from 'fp-ts/Functor';
import * as FuWI from 'fp-ts/FunctorWithIndex';
import { Kind, Kind2, Kind3, Kind4, URIS, URIS2, URIS3, URIS4 } from 'fp-ts/HKT';
import * as IO from 'fp-ts/IO';
import * as Mona from 'fp-ts/Monad';
import * as MIO from 'fp-ts/MonadIO';
import * as Mono from 'fp-ts/Monoid';
import * as Op from 'fp-ts/Option';
import * as Or from 'fp-ts/Ord';
import * as P from 'fp-ts/Pointed';
import * as RNEA from 'fp-ts/ReadonlyNonEmptyArray';
import * as S from 'fp-ts/Separated';
import * as T from 'fp-ts/Traversable';
import * as TWI from 'fp-ts/TraversableWithIndex';
import * as U from 'fp-ts/Unfoldable';
import * as W from 'fp-ts/Witherable';
import { Int } from 'io-ts';
export declare const URI = "GeneratorL";
export declare type URI = typeof URI;
declare module 'fp-ts/HKT' {
    interface URItoKind<A> {
        [URI]: GeneratorL<A>;
    }
}
export declare type GeneratorL<A> = Lazy<Generator<A>>;
export declare const getMonoid: <A>() => Mono.Monoid<GeneratorL<A>>;
export declare const getEq: <A>(E: Eq.Eq<A>) => Eq.Eq<GeneratorL<A>>;
export declare const getOrd: <A>(O: Or.Ord<A>) => Or.Ord<GeneratorL<A>>;
export declare const Functor: Fu.Functor1<URI>;
export declare const map: <A, B>(a: (a: A) => B) => (b: GeneratorL<A>) => GeneratorL<B>;
export declare const flap: <A>(a: A) => <B>(fab: GeneratorL<(a: A) => B>) => GeneratorL<B>;
export declare const bindTo: <N extends string>(name: N) => <A>(fa: GeneratorL<A>) => GeneratorL<{ readonly [K in N]: A; }>;
export declare const Pointed: P.Pointed1<URI>;
export declare const of: <A>(a: A) => GeneratorL<A>;
export declare const Do: GeneratorL<{}>;
export declare const FunctorWithIndex: FuWI.FunctorWithIndex1<URI, number>;
export declare const mapWithIndex: <A, B>(a: (i: number, a: A) => B) => (b: GeneratorL<A>) => GeneratorL<B>;
export declare const Apply: _Apply.Apply1<URI>;
export declare const ap: <A, B>(a: GeneratorL<A>) => (b: GeneratorL<(a: A) => B>) => GeneratorL<B>;
export declare const apFirst: <B>(second: GeneratorL<B>) => <A>(first: GeneratorL<A>) => GeneratorL<A>;
export declare const apSecond: <B>(second: GeneratorL<B>) => <A>(first: GeneratorL<A>) => GeneratorL<B>;
export declare const apS: <N extends string, A, B>(name: Exclude<N, keyof A>, fb: GeneratorL<B>) => (fa: GeneratorL<A>) => GeneratorL<{ readonly [K in N | keyof A]: K extends keyof A ? A[K] : B; }>;
export declare const Applicative: Appli.Applicative1<URI>;
export declare const Chain: Ch.Chain1<URI>;
export declare const chain: <A, B>(a: (a: A) => GeneratorL<B>) => (b: GeneratorL<A>) => GeneratorL<B>;
export declare const chainFirst: <A, B>(f: (a: A) => GeneratorL<B>) => (first: GeneratorL<A>) => GeneratorL<A>;
export declare const bind: <N extends string, A, B>(name: Exclude<N, keyof A>, f: (a: A) => GeneratorL<B>) => (ma: GeneratorL<A>) => GeneratorL<{ readonly [K in N | keyof A]: K extends keyof A ? A[K] : B; }>;
export declare const chainWithIndex: <A, B>(f: (i: number, a: A) => GeneratorL<B>) => (fa: GeneratorL<A>) => GeneratorL<B>;
export declare const Monad: Mona.Monad1<URI>;
export declare const FromIO: FIO.FromIO1<URI>;
export declare const fromIO: <A>(fa: IO.IO<A>) => GeneratorL<A>;
export declare const fromIOK: <A extends readonly unknown[], B>(f: (...a: A) => IO.IO<B>) => (...a: A) => GeneratorL<B>;
export declare const chainIOK: <A, B>(f: (a: A) => IO.IO<B>) => (first: GeneratorL<A>) => GeneratorL<B>;
export declare const chainFirstIOK: <A, B>(f: (a: A) => IO.IO<B>) => (first: GeneratorL<A>) => GeneratorL<A>;
export declare const MonadIO: MIO.MonadIO1<URI>;
export declare const Unfoldable: U.Unfoldable1<URI>;
export declare const unfold: <A, B>(a: (b: B) => Op.Option<[A, B]>) => (b: B) => GeneratorL<A>;
export declare const Alt: $generatorL.Alt1<URI>;
export declare const alt: <A>(a: Lazy<GeneratorL<A>>) => (b: GeneratorL<A>) => GeneratorL<A>;
export declare const Alternative: Alte.Alternative1<URI>;
export declare const zero: <A>() => GeneratorL<A>;
export declare const Extend: Ex.Extend1<URI>;
export declare const extend: <A, B>(a: (wa: GeneratorL<A>) => B) => (b: GeneratorL<A>) => GeneratorL<B>;
export declare const duplicate: <A>(fa: GeneratorL<A>) => GeneratorL<GeneratorL<A>>;
export declare const Compactable: Co.Compactable1<URI>;
export declare const compact: <A>(fa: GeneratorL<Op.Option<A>>) => GeneratorL<A>;
export declare const separate: <A, B>(fa: GeneratorL<Ei.Either<A, B>>) => S.Separated<GeneratorL<A>, GeneratorL<B>>;
export declare const Filterable: Fi.Filterable1<URI>;
export declare function filter<A, B extends A>(refinement: Refinement<A, B>): (fa: GeneratorL<A>) => GeneratorL<B>;
export declare function filter<A>(predicate: Predicate<A>): (fa: GeneratorL<A>) => GeneratorL<A>;
export declare const filterMap: <A, B>(a: (a: A) => Op.Option<B>) => (b: GeneratorL<A>) => GeneratorL<B>;
export declare function partition<A, B extends A>(refinement: Refinement<A, B>): (fa: GeneratorL<A>) => S.Separated<GeneratorL<A>, GeneratorL<B>>;
export declare function partition<A>(predicate: Predicate<A>): (fa: GeneratorL<A>) => S.Separated<GeneratorL<A>, GeneratorL<A>>;
export declare const partitionMap: <A, B, C>(a: (a: A) => Ei.Either<B, C>) => (b: GeneratorL<A>) => S.Separated<GeneratorL<B>, GeneratorL<C>>;
export declare const FilterableWithIndex: FiWI.FilterableWithIndex1<URI, number>;
export declare function filterWithIndex<A, B extends A>(refinementWithIndex: (i: number, a: A) => a is B): (fa: GeneratorL<A>) => GeneratorL<B>;
export declare function filterWithIndex<A>(predicateWithIndex: (i: number, a: A) => boolean): (fa: GeneratorL<A>) => GeneratorL<A>;
export declare const filterMapWithIndex: <A, B>(a: (i: number, a: A) => Op.Option<B>) => (b: GeneratorL<A>) => GeneratorL<B>;
export declare function partitionWithIndex<A, B extends A>(refinementWithIndex: (i: number, a: A) => a is B): (fa: GeneratorL<A>) => S.Separated<GeneratorL<A>, GeneratorL<B>>;
export declare function partitionWithIndex<A>(predicateWithIndex: (i: number, a: A) => boolean): (fa: GeneratorL<A>) => S.Separated<GeneratorL<A>, GeneratorL<A>>;
export declare const partitionMapWithIndex: <A, B, C>(a: (i: number, a: A) => Ei.Either<B, C>) => (b: GeneratorL<A>) => S.Separated<GeneratorL<B>, GeneratorL<C>>;
export declare const Foldable: Fo.Foldable1<URI>;
export declare const reduce: <A, B>(b: B, f: (b: B, a: A) => B) => (fa: GeneratorL<A>) => B;
export declare const foldMap: <M>(M: Mono.Monoid<M>) => <A>(f: (a: A) => M) => (fa: GeneratorL<A>) => M;
export declare const reduceRight: <A, B>(b: B, f: (a: A, b: B) => B) => (fa: GeneratorL<A>) => B;
export declare const FoldableWithIndex: FoWI.FoldableWithIndex1<URI, number>;
export declare const reduceWithIndex: <A, B>(b: B, f: (i: number, b: B, a: A) => B) => (fa: GeneratorL<A>) => B;
export declare const foldMapWithIndex: <M>(M: Mono.Monoid<M>) => <A>(f: (i: number, a: A) => M) => (fa: GeneratorL<A>) => M;
export declare const reduceRightWithIndex: <A, B>(b: B, f: (i: number, a: A, b: B) => B) => (fa: GeneratorL<A>) => B;
export declare function sequence<F extends URIS4>(F: Appli.Applicative4<F>): <S, R, E, A>(ta: GeneratorL<Kind4<F, S, R, E, A>>) => Kind4<F, S, R, E, GeneratorL<A>>;
export declare function sequence<F extends URIS3>(F: Appli.Applicative3<F>): <R, E, A>(ta: GeneratorL<Kind3<F, R, E, A>>) => Kind3<F, R, E, GeneratorL<A>>;
export declare function sequence<F extends URIS3, E>(F: Appli.Applicative3C<F, E>): <R, A>(ta: GeneratorL<Kind3<F, R, E, A>>) => Kind3<F, R, E, GeneratorL<A>>;
export declare function sequence<F extends URIS2>(F: Appli.Applicative2<F>): <E, A>(ta: GeneratorL<Kind2<F, E, A>>) => Kind2<F, E, GeneratorL<A>>;
export declare function sequence<F extends URIS2, E>(F: Appli.Applicative2C<F, E>): <A>(ta: GeneratorL<Kind2<F, E, A>>) => Kind2<F, E, GeneratorL<A>>;
export declare function sequence<F extends URIS>(F: Appli.Applicative1<F>): <A>(ta: GeneratorL<Kind<F, A>>) => Kind<F, GeneratorL<A>>;
export declare const Traversable: T.Traversable1<URI>;
export declare function traverse<F extends URIS4>(F: Appli.Applicative4<F>): <A, S, R, E, B>(f: (a: A) => Kind4<F, S, R, E, B>) => (ta: GeneratorL<A>) => Kind4<F, S, R, E, GeneratorL<B>>;
export declare function traverse<F extends URIS3>(F: Appli.Applicative3<F>): <A, R, E, B>(f: (a: A) => Kind3<F, R, E, B>) => (ta: GeneratorL<A>) => Kind3<F, R, E, GeneratorL<B>>;
export declare function traverse<F extends URIS3, E>(F: Appli.Applicative3C<F, E>): <A, R, B>(f: (a: A) => Kind3<F, R, E, B>) => (ta: GeneratorL<A>) => Kind3<F, R, E, GeneratorL<B>>;
export declare function traverse<F extends URIS2>(F: Appli.Applicative2<F>): <A, E, B>(f: (a: A) => Kind2<F, E, B>) => (ta: GeneratorL<A>) => Kind2<F, E, GeneratorL<B>>;
export declare function traverse<F extends URIS2, E>(F: Appli.Applicative2C<F, E>): <A, B>(f: (a: A) => Kind2<F, E, B>) => (ta: GeneratorL<A>) => Kind2<F, E, GeneratorL<B>>;
export declare function traverse<F extends URIS>(F: Appli.Applicative1<F>): <A, B>(f: (a: A) => Kind<F, B>) => (ta: GeneratorL<A>) => Kind<F, GeneratorL<B>>;
export declare const TraversableWithIndex: TWI.TraversableWithIndex1<URI, number>;
export declare function traverseWithIndex<F extends URIS4>(F: Appli.Applicative4<F>): <A, S, R, E, B>(f: (i: number, a: A) => Kind4<F, S, R, E, B>) => (ta: GeneratorL<A>) => Kind4<F, S, R, E, GeneratorL<B>>;
export declare function traverseWithIndex<F extends URIS3>(F: Appli.Applicative3<F>): <A, R, E, B>(f: (i: number, a: A) => Kind3<F, R, E, B>) => (ta: GeneratorL<A>) => Kind3<F, R, E, GeneratorL<B>>;
export declare function traverseWithIndex<F extends URIS3, E>(F: Appli.Applicative3C<F, E>): <A, R, B>(f: (i: number, a: A) => Kind3<F, R, E, B>) => (ta: GeneratorL<A>) => Kind3<F, R, E, GeneratorL<B>>;
export declare function traverseWithIndex<F extends URIS2>(F: Appli.Applicative2<F>): <A, E, B>(f: (i: number, a: A) => Kind2<F, E, B>) => (ta: GeneratorL<A>) => Kind2<F, E, GeneratorL<B>>;
export declare function traverseWithIndex<F extends URIS2, E>(F: Appli.Applicative2C<F, E>): <A, B>(f: (i: number, a: A) => Kind2<F, E, B>) => (ta: GeneratorL<A>) => Kind2<F, E, GeneratorL<B>>;
export declare function traverseWithIndex<F extends URIS>(F: Appli.Applicative1<F>): <A, B>(f: (i: number, a: A) => Kind<F, B>) => (ta: GeneratorL<A>) => Kind<F, GeneratorL<B>>;
export declare const Witherable: W.Witherable1<URI>;
export declare function wilt<F extends URIS3>(F: Appli.Applicative3<F>): <A, R, E, B, C>(f: (a: A) => Kind3<F, R, E, Ei.Either<B, C>>) => (wa: GeneratorL<A>) => Kind3<F, R, E, S.Separated<GeneratorL<B>, GeneratorL<C>>>;
export declare function wilt<F extends URIS3, E>(F: Appli.Applicative3C<F, E>): <A, R, B, C>(f: (a: A) => Kind3<F, R, E, Ei.Either<B, C>>) => (wa: GeneratorL<A>) => Kind3<F, R, E, S.Separated<GeneratorL<B>, GeneratorL<C>>>;
export declare function wilt<F extends URIS2>(F: Appli.Applicative2<F>): <A, E, B, C>(f: (a: A) => Kind2<F, E, Ei.Either<B, C>>) => (wa: GeneratorL<A>) => Kind2<F, E, S.Separated<GeneratorL<B>, GeneratorL<C>>>;
export declare function wilt<F extends URIS2, E>(F: Appli.Applicative2C<F, E>): <A, B, C>(f: (a: A) => Kind2<F, E, Ei.Either<B, C>>) => (wa: GeneratorL<A>) => Kind2<F, E, S.Separated<GeneratorL<B>, GeneratorL<C>>>;
export declare function wilt<F extends URIS>(F: Appli.Applicative1<F>): <A, B, C>(f: (a: A) => Kind<F, Ei.Either<B, C>>) => (wa: GeneratorL<A>) => Kind<F, S.Separated<GeneratorL<B>, GeneratorL<C>>>;
export declare function wither<F extends URIS3>(F: Appli.Applicative3<F>): <A, R, E, B>(f: (a: A) => Kind3<F, R, E, Op.Option<B>>) => (ta: GeneratorL<A>) => Kind3<F, R, E, GeneratorL<B>>;
export declare function wither<F extends URIS3, E>(F: Appli.Applicative3C<F, E>): <A, R, B>(f: (a: A) => Kind3<F, R, E, Op.Option<B>>) => (ta: GeneratorL<A>) => Kind3<F, R, E, GeneratorL<B>>;
export declare function wither<F extends URIS2>(F: Appli.Applicative2<F>): <A, E, B>(f: (a: A) => Kind2<F, E, Op.Option<B>>) => (ta: GeneratorL<A>) => Kind2<F, E, GeneratorL<B>>;
export declare function wither<F extends URIS2, E>(F: Appli.Applicative2C<F, E>): <A, B>(f: (a: A) => Kind2<F, E, Op.Option<B>>) => (ta: GeneratorL<A>) => Kind2<F, E, GeneratorL<B>>;
export declare function wither<F extends URIS>(F: Appli.Applicative1<F>): <A, B>(f: (a: A) => Kind<F, Op.Option<B>>) => (ta: GeneratorL<A>) => Kind<F, GeneratorL<B>>;
export declare const makeBy: <A>(f: (i: number) => A) => GeneratorL<A>;
export declare const range: (start: number, end?: number) => GeneratorL<number>;
export declare const replicate: <A>(a: A) => GeneratorL<A>;
export declare const fromReadonlyArray: <A>(as: readonly A[]) => GeneratorL<A>;
export declare const fromReadonlyRecord: <K extends string, A>(r: Readonly<Record<K, A>>) => GeneratorL<readonly [K, A]>;
export declare const random: GeneratorL<number>;
export declare const randomInt: (low: number, high: number) => GeneratorL<Int>;
export declare const randomRange: (min: number, max: number) => GeneratorL<number>;
export declare const randomBool: GeneratorL<boolean>;
export declare const randomElem: <A>(as: RNEA.ReadonlyNonEmptyArray<A>) => GeneratorL<A>;
export declare const prime: GeneratorL<number>;
export declare const exp: GeneratorL<number>;
export declare const fibonacci: GeneratorL<number>;
export declare const flatten: <A>(mma: GeneratorL<GeneratorL<A>>) => GeneratorL<A>;
export declare const prepend: <A>(a: A) => (ma: GeneratorL<A>) => GeneratorL<A>;
export declare const append: <A>(a: A) => (ma: GeneratorL<A>) => GeneratorL<A>;
export declare const takeLeft: (n: number) => <A>(ma: GeneratorL<A>) => GeneratorL<A>;
export declare const takeRight: (n: number) => <A>(ma: GeneratorL<A>) => GeneratorL<A>;
export declare function takeLeftWhile<A, B extends A>(refinement: Refinement<A, B>): (ma: GeneratorL<A>) => GeneratorL<B>;
export declare function takeLeftWhile<A>(predicate: Predicate<A>): (ma: GeneratorL<A>) => GeneratorL<A>;
export declare const dropLeft: (n: number) => <A>(ma: GeneratorL<A>) => GeneratorL<A>;
export declare const dropRight: (n: number) => <A>(ma: GeneratorL<A>) => GeneratorL<A>;
export declare function dropLeftWhile<A, B extends A>(refinement: Refinement<A, B>): (ma: GeneratorL<A>) => GeneratorL<B>;
export declare function dropLeftWhile<A>(predicate: Predicate<A>): (ma: GeneratorL<A>) => GeneratorL<A>;
export declare const scanLeft: <A, B>(b: B, f: (b: B, a: A) => B) => (ma: GeneratorL<A>) => GeneratorL<B>;
export declare const scanRight: <A, B>(b: B, f: (a: A, b: B) => B) => (ma: GeneratorL<A>) => GeneratorL<B>;
export declare function sieve<A>(f: (init: ReadonlyArray<A>, a: A) => boolean): (ma: GeneratorL<A>) => GeneratorL<A>;
export declare const uniq: <A>(E: Eq.Eq<A>) => (ma: GeneratorL<A>) => GeneratorL<A>;
export declare const sort: <B>(O: Or.Ord<B>) => <A extends B>(ma: GeneratorL<A>) => GeneratorL<A>;
export declare const sortBy: <B>(Os: readonly Or.Ord<B>[]) => <A extends B>(ma: GeneratorL<A>) => GeneratorL<A>;
export declare const reverse: <A>(ma: GeneratorL<A>) => GeneratorL<A>;
export declare const zipWith: <A, B, C>(mb: GeneratorL<B>, f: (a: A, b: B) => C) => (ma: GeneratorL<A>) => GeneratorL<C>;
export declare const zip: <B>(mb: GeneratorL<B>) => <A>(ma: GeneratorL<A>) => GeneratorL<readonly [A, B]>;
export declare const rights: <E, A>(ma: GeneratorL<Ei.Either<E, A>>) => GeneratorL<A>;
export declare const lefts: <E, A>(ma: GeneratorL<Ei.Either<E, A>>) => GeneratorL<E>;
export declare const prependAll: <A>(middle: A) => (ma: GeneratorL<A>) => GeneratorL<A>;
export declare const intersperse: <A>(middle: A) => (ma: GeneratorL<A>) => GeneratorL<A>;
export declare const rotate: (n: number) => <A>(ma: GeneratorL<A>) => GeneratorL<A>;
export declare const chop: <A, B>(f: (ma: GeneratorL<A>) => readonly [B, GeneratorL<A>]) => (ma: GeneratorL<A>) => GeneratorL<B>;
export declare const chunksOf: (n: number) => <A>(ma: GeneratorL<A>) => GeneratorL<GeneratorL<A>>;
export declare const matchLeft: <A, B>(onEmpty: Lazy<B>, onNonEmpty: (head: A, tail: GeneratorL<A>) => B) => (ma: GeneratorL<A>) => B;
export declare const matchRight: <A, B>(onEmpty: Lazy<B>, onNonEmpty: (init: GeneratorL<A>, last: A) => B) => (ma: GeneratorL<A>) => B;
export declare const toReadonlyArray: <A>(ma: GeneratorL<A>) => readonly A[];
export declare const lookup: (i: number) => <A>(ma: GeneratorL<A>) => Op.Option<A>;
export declare const head: <A>(ma: GeneratorL<A>) => Op.Option<A>;
export declare const last: <A>(ma: GeneratorL<A>) => Op.Option<A>;
export declare const tail: <A>(ma: GeneratorL<A>) => Op.Option<GeneratorL<A>>;
export declare const init: <A>(ma: GeneratorL<A>) => Op.Option<GeneratorL<A>>;
export interface Spanned<I, R> {
    init: GeneratorL<I>;
    rest: GeneratorL<R>;
}
export declare function spanLeft<A, B extends A>(refinement: Refinement<A, B>): (ma: GeneratorL<A>) => Spanned<B, A>;
export declare function spanLeft<A>(predicate: Predicate<A>): (ma: GeneratorL<A>) => Spanned<A, A>;
export declare const splitAt: (n: number) => <A>(ma: GeneratorL<A>) => readonly [GeneratorL<A>, GeneratorL<A>];
export declare const unzip: <A, B>(mab: GeneratorL<readonly [A, B]>) => readonly [GeneratorL<A>, GeneratorL<B>];
export declare const isEmpty: (ma: GeneratorL<unknown>) => boolean;
export declare const isNonEmpty: Predicate<GeneratorL<unknown>>;
export declare const size: (b: GeneratorL<unknown>) => number;
export declare const isOutOfBound: (n: number) => (ma: GeneratorL<unknown>) => boolean;
export declare function findFirst<A, B extends A>(refinement: Refinement<A, B>): (ma: GeneratorL<A>) => Op.Option<B>;
export declare function findFirst<A>(predicate: Predicate<A>): (ma: GeneratorL<A>) => Op.Option<A>;
export declare const findFirstMap: <A, B>(f: (a: A) => Op.Option<B>) => (ma: GeneratorL<A>) => Op.Option<B>;
export declare const findFirstIndex: <A>(predicate: Predicate<A>) => (ma: GeneratorL<A>) => Op.Option<number>;
export declare function findLast<A, B extends A>(refinement: Refinement<A, B>): (ma: GeneratorL<A>) => Op.Option<B>;
export declare function findLast<A>(predicate: Predicate<A>): (ma: GeneratorL<A>) => Op.Option<A>;
export declare const findLastMap: <A, B>(f: (a: A) => Op.Option<B>) => (ma: GeneratorL<A>) => Op.Option<B>;
export declare const findLastIndex: <A>(predicate: Predicate<A>) => (ma: GeneratorL<A>) => Op.Option<number>;
export declare const elem: <A>(Eq: Eq.Eq<A>) => (a: A) => (ma: GeneratorL<A>) => Op.Option<A>;
export declare const insertAt: <A>(i: number, a: A) => (ma: GeneratorL<A>) => Op.Option<GeneratorL<A>>;
export declare const modifyAt: <A>(i: number, f: (a: A) => A) => (ma: GeneratorL<A>) => Op.Option<GeneratorL<A>>;
export declare const updateAt: <A>(i: number, a: A) => (ma: GeneratorL<A>) => Op.Option<GeneratorL<A>>;
export declare const deleteAt: <A>(i: number) => (ma: GeneratorL<A>) => Op.Option<GeneratorL<A>>;
