import * as Appli from 'fp-ts/Applicative';
import * as _Apply from 'fp-ts/Apply';
import * as Ch from 'fp-ts/Chain';
import * as Co from 'fp-ts/Compactable';
import * as Ei from 'fp-ts/Either';
import * as Eq from 'fp-ts/Eq';
import * as Fi from 'fp-ts/Filterable';
import * as FiWI from 'fp-ts/FilterableWithIndex';
import * as FIO from 'fp-ts/FromIO';
import { Lazy, Predicate, Refinement } from 'fp-ts/function';
import * as Fu from 'fp-ts/Functor';
import * as FuWI from 'fp-ts/FunctorWithIndex';
import * as IO from 'fp-ts/IO';
import * as Mona from 'fp-ts/Monad';
import * as MIO from 'fp-ts/MonadIO';
import * as Mono from 'fp-ts/Monoid';
import * as O from 'fp-ts/Option';
import * as P from 'fp-ts/Pointed';
import * as S from 'fp-ts/Separated';
import * as T from 'fp-ts/Task';
import * as $IOG from './GeneratorL';
export declare const URI = "IOAsyncGenerator";
export declare type URI = typeof URI;
declare module 'fp-ts/HKT' {
    interface URItoKind<A> {
        [URI]: IOAsyncGenerator<A>;
    }
}
export declare type IOAsyncGenerator<A> = IO.IO<AsyncGenerator<A>>;
export declare const getMonoid: <A>() => Mono.Monoid<IOAsyncGenerator<A>>;
export declare const fromIOGenerator: <A>(as: $IOG.GeneratorL<A>) => IOAsyncGenerator<A>;
export declare const Functor: Fu.Functor1<URI>;
export declare const map: <A, B>(a: (a: A) => B) => (b: IOAsyncGenerator<A>) => IOAsyncGenerator<B>;
export declare const flap: <A>(a: A) => <B>(fab: IOAsyncGenerator<(a: A) => B>) => IOAsyncGenerator<B>;
export declare const bindTo: <N extends string>(name: N) => <A>(fa: IOAsyncGenerator<A>) => IOAsyncGenerator<{ readonly [K in N]: A; }>;
export declare const FunctorWithIndex: FuWI.FunctorWithIndex1<URI, number>;
export declare const Pointed: P.Pointed1<URI>;
export declare const of: <A>(a: A) => IOAsyncGenerator<A>;
export declare const Do: IOAsyncGenerator<{}>;
export declare const ApplyPar: _Apply.Apply1<URI>;
/**
 *
 */
export declare const ApplySeq: _Apply.Apply1<URI>;
export declare const ap: <A, B>(a: IOAsyncGenerator<A>) => (b: IOAsyncGenerator<(a: A) => B>) => IOAsyncGenerator<B>;
export declare const apFirst: <B>(second: IOAsyncGenerator<B>) => <A>(first: IOAsyncGenerator<A>) => IOAsyncGenerator<A>;
export declare const apSecond: <B>(second: IOAsyncGenerator<B>) => <A>(first: IOAsyncGenerator<A>) => IOAsyncGenerator<B>;
export declare const apS: <N extends string, A, B>(name: Exclude<N, keyof A>, fb: IOAsyncGenerator<B>) => (fa: IOAsyncGenerator<A>) => IOAsyncGenerator<{ readonly [K in N | keyof A]: K extends keyof A ? A[K] : B; }>;
export declare const ApplicativePar: Appli.Applicative1<URI>;
export declare const ApplicativeSeq: Appli.Applicative1<URI>;
export declare const Chain: Ch.Chain1<URI>;
export declare const chain: <A, B>(a: (a: A) => IOAsyncGenerator<B>) => (b: IOAsyncGenerator<A>) => IOAsyncGenerator<B>;
export declare const chainFirst: <A, B>(f: (a: A) => IOAsyncGenerator<B>) => (first: IOAsyncGenerator<A>) => IOAsyncGenerator<A>;
export declare const bind: <N extends string, A, B>(name: Exclude<N, keyof A>, f: (a: A) => IOAsyncGenerator<B>) => (ma: IOAsyncGenerator<A>) => IOAsyncGenerator<{ readonly [K in N | keyof A]: K extends keyof A ? A[K] : B; }>;
export declare const Monad: Mona.Monad1<URI>;
export declare const FromIO: FIO.FromIO1<URI>;
export declare const fromIO: <A>(fa: IO.IO<A>) => IOAsyncGenerator<A>;
export declare const fromIOK: <A extends readonly unknown[], B>(f: (...a: A) => IO.IO<B>) => (...a: A) => IOAsyncGenerator<B>;
export declare const chainIOK: <A, B>(f: (a: A) => IO.IO<B>) => (first: IOAsyncGenerator<A>) => IOAsyncGenerator<B>;
export declare const chainFirstIOK: <A, B>(f: (a: A) => IO.IO<B>) => (first: IOAsyncGenerator<A>) => IOAsyncGenerator<A>;
export declare const fromIOReadonlyArray: <A>(fa: IO.IO<readonly A[]>) => IOAsyncGenerator<A>;
export declare const fromIOReadonlyArrayK: <A extends readonly unknown[], B>(f: (...a: A) => IO.IO<readonly B[]>) => (...a: A) => IOAsyncGenerator<B>;
export declare const chainIOReadonlyArrayK: <A, B>(f: (a: A) => IO.IO<readonly B[]>) => (b: IOAsyncGenerator<A>) => IOAsyncGenerator<B>;
export declare const MonadIO: MIO.MonadIO1<URI>;
export declare const Compactable: Co.Compactable1<URI>;
export declare const compact: <A>(fa: IOAsyncGenerator<O.Option<A>>) => IOAsyncGenerator<A>;
export declare const separate: <A, B>(fa: IOAsyncGenerator<Ei.Either<A, B>>) => S.Separated<IOAsyncGenerator<A>, IOAsyncGenerator<B>>;
export declare const Filterable: Fi.Filterable1<URI>;
export declare function filter<A, B extends A>(refinement: Refinement<A, B>): (fa: IOAsyncGenerator<A>) => IOAsyncGenerator<B>;
export declare function filter<A>(predicate: Predicate<A>): (fa: IOAsyncGenerator<A>) => IOAsyncGenerator<A>;
export declare const filterMap: <A, B>(a: (a: A) => O.Option<B>) => (b: IOAsyncGenerator<A>) => IOAsyncGenerator<B>;
export declare function partition<A, B extends A>(refinement: Refinement<A, B>): (fa: IOAsyncGenerator<A>) => S.Separated<IOAsyncGenerator<A>, IOAsyncGenerator<B>>;
export declare function partition<A>(predicate: Predicate<A>): (fa: IOAsyncGenerator<A>) => S.Separated<IOAsyncGenerator<A>, IOAsyncGenerator<A>>;
export declare const partitionMap: <A, B, C>(a: (a: A) => Ei.Either<B, C>) => (b: IOAsyncGenerator<A>) => S.Separated<IOAsyncGenerator<B>, IOAsyncGenerator<C>>;
export declare const FilterableWithIndex: FiWI.FilterableWithIndex1<URI, number>;
export declare function filterWithIndex<A, B extends A>(refinementWithIndex: (i: number, a: A) => a is B): (fa: IOAsyncGenerator<A>) => IOAsyncGenerator<B>;
export declare function filterWithIndex<A>(predicateWithIndex: (i: number, a: A) => boolean): (fa: IOAsyncGenerator<A>) => IOAsyncGenerator<A>;
export declare const filterMapWithIndex: <A, B>(a: (i: number, a: A) => O.Option<B>) => (b: IOAsyncGenerator<A>) => IOAsyncGenerator<B>;
export declare function partitionWithIndex<A, B extends A>(refinementWithIndex: (i: number, a: A) => a is B): (fa: IOAsyncGenerator<A>) => S.Separated<IOAsyncGenerator<A>, IOAsyncGenerator<B>>;
export declare function partitionWithIndex<A>(predicateWithIndex: (i: number, a: A) => boolean): (fa: IOAsyncGenerator<A>) => S.Separated<IOAsyncGenerator<A>, IOAsyncGenerator<A>>;
export declare const partitionMapWithIndex: <A, B, C>(a: (i: number, a: A) => Ei.Either<B, C>) => (b: IOAsyncGenerator<A>) => S.Separated<IOAsyncGenerator<B>, IOAsyncGenerator<C>>;
export declare const range: (start: number, end?: number | undefined) => IOAsyncGenerator<number>;
export declare const replicate: <A>(a: A) => IOAsyncGenerator<A>;
export declare const fromReadonlyArray: <A>(x: readonly A[]) => IOAsyncGenerator<A>;
export declare const sieve: <A>(f: (init: readonly A[], a: A) => boolean) => (as: IOAsyncGenerator<A>) => IOAsyncGenerator<A>;
export declare const prime: IOAsyncGenerator<number>;
export declare const exp: IOAsyncGenerator<number>;
export declare const fibonacci: IOAsyncGenerator<number>;
export declare const flatten: <A>(as: IOAsyncGenerator<IOAsyncGenerator<A>>) => IOAsyncGenerator<A>;
export declare const take: <A>(n: number) => (as: IOAsyncGenerator<A>) => IOAsyncGenerator<A>;
export declare const drop: <A>(n: number) => (as: IOAsyncGenerator<A>) => IOAsyncGenerator<A>;
export declare const zip: <A, B>(bs: IOAsyncGenerator<B>) => (as: IOAsyncGenerator<A>) => IOAsyncGenerator<readonly [A, B]>;
export declare const uniq: <A>(E: Eq.Eq<A>) => (as: IOAsyncGenerator<A>) => IOAsyncGenerator<A>;
export declare const match: <A, B>(onEmpty: Lazy<B>, onNonEmpty: (head: A, tail: IOAsyncGenerator<A>) => B) => (as: IOAsyncGenerator<A>) => T.Task<B>;
export declare const toTask: <A>(as: IOAsyncGenerator<A>) => T.Task<readonly A[]>;
export declare const isEmpty: (as: IOAsyncGenerator<unknown>) => T.Task<boolean>;
export declare const isNonEmpty: (as: IOAsyncGenerator<unknown>) => T.Task<boolean>;
export declare const lookup: <A>(i: number) => (as: IOAsyncGenerator<A>) => T.Task<O.Option<A>>;
export declare const head: <A>(as: IOAsyncGenerator<A>) => T.Task<O.Option<A>>;
export declare function find<A, B extends A>(refinement: Refinement<A, B>): (as: IOAsyncGenerator<A>) => T.Task<O.Option<B>>;
export declare function find<A>(predicate: Predicate<A>): (as: IOAsyncGenerator<A>) => T.Task<O.Option<A>>;
export declare const elem: <A>(Eq: Eq.Eq<A>) => (a: A) => (as: IOAsyncGenerator<A>) => T.Task<O.Option<A>>;
